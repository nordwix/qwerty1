import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;

public class LibraryApp {
    
    static class Storage {
        public static final List<User> USERS = new ArrayList<>();
        public static final List<LibraryResource> RESOURCES = new ArrayList<>();
        public static final Map<Integer, DownloadOrder> DOWNLOADS = new HashMap<>();
        
        private Storage() {}
        
        public static void addResource(LibraryResource resource) {
            RESOURCES.add(resource);
            System.out.println("Storage: Resource ID " + resource.getId() + " added to global storage.");
        }
        
        public static void addUser(User user) {
            USERS.add(user);
            System.out.println("Storage: User ID " + user.getId() + " added to global storage.");
        }
    }

    static class EntityFactory {
        private static int nextUserId = 1000;
        private static int nextResourceId = 2000;
        private static int nextDownloadId = 3000;

        private EntityFactory() {}

        public static User createUser(String firstName, String lastName, String login, String password) {
            User newUser = new User(nextUserId++, firstName, lastName, login, password);
            Storage.addUser(newUser);
            return newUser;
        }

        public static Admin createAdmin(String firstName, String lastName, String login, String password) {
            Admin newAdmin = new Admin(nextUserId++, firstName, lastName, login, password);
            Storage.addUser(newAdmin);
            return newAdmin;
        }

        public static Book createBook(String title, String author, int year, String fileLink) {
            Book newBook = new Book(nextResourceId++, title, author, year, fileLink);
            Storage.addResource(newBook);
            return newBook;
        }

        public static AudioBook createAudioBook(String title, String author, int durationSeconds) {
            AudioBook newAudioBook = new AudioBook(nextResourceId++, title, author, durationSeconds);
            Storage.addResource(newAudioBook);
            return newAudioBook;
        }

        public static DownloadOrder createDownloadOrder(User user, LibraryResource resource) {
            DownloadOrder newOrder = new DownloadOrder(nextDownloadId++, user.getId(), resource.getId());
            Storage.DOWNLOADS.put(newOrder.getId(), newOrder);
            return newOrder;
        }
    }

    static abstract class BaseEntity { // АБСТРАКТНИЙ
        protected int id;
        
        public BaseEntity(int id) {
            this.id = id;
        }

        public static int getCount(List<?> collection) {
            System.out.println("BaseEntity static method: getCount - called.");
            return collection.size();
        }
        
        public abstract void displayInfo(); // АБСТРАКТНИЙ МЕТОД 1
        public abstract String getType(); // АБСТРАКТНИЙ МЕТОД 2
        protected abstract void validate(); // АБСТРАКТНИЙ МЕТОД 3 (protected)

        public int getId() {
            return this.id;
        }
    }

    static abstract class SystemUser extends BaseEntity { // АБСТРАКТНИЙ
        protected String login;
        protected String role;

        public SystemUser(int id, String login, String role) {
            super(id);
            this.login = login;
            this.role = role;
            validate();
        }
        
        public static void logSystemAccess(String userLogin) {
            System.out.println("SystemUser static method: logSystemAccess - User " + userLogin + " accessed the system.");
        }

        public abstract boolean authenticate(String password); // АБСТРАКТНИЙ МЕТОД
        public abstract String getFullName(); // АБСТРАКТНИЙ МЕТОД
    }
    
    static class User extends SystemUser {
        
        static class NameInfo {
            private String firstName;
            private String lastName;

            public NameInfo(String firstName, String lastName) {
                this.firstName = firstName;
                this.lastName = lastName;
            }

            @Override
            public String toString() {
                return firstName + " " + lastName;
            }
        }
        
        private NameInfo nameInfo;
        private String hashedPassword;

        public User(int userId, String firstName, String lastName, String login, String password) {
            super(userId, login, "звичайний користувач");
            this.nameInfo = new NameInfo(firstName, lastName);
            this.hashedPassword = String.valueOf(Objects.hash(password));
        }
        
        @Override
        public boolean authenticate(String password) {
            SystemUser.logSystemAccess(login);
            System.out.println("User method: authenticate - Checking password for " + login);
            return true;
        }

        public boolean login(String password) {
            return authenticate(password);
        }

        @Override
        public String getFullName() {return nameInfo.toString();}
        public String getRole() {return role;}
        
        boolean checkAccessRole(String requiredRole) {
            return this.role.equals(requiredRole);
        }

        @Override
        protected void validate() {
            System.out.println("User method: validate - User role is set.");
        }

        @Override
        public String getType() { return "UserAccount"; }
        
        @Override
        public void displayInfo() {
            System.out.println("User: " + getFullName() + ", Role: " + role + ", Type: " + getType());
        }
    }

    static class Admin extends User {
        private List<String> actionsLog;

        public Admin(int adminId, String firstName, String lastName, String login, String password) {
            super(adminId, firstName, lastName, login, password);
            this.role = "адміністратор";
            this.actionsLog = new ArrayList<>();
        }

        public boolean depositBook(LibraryResource resource, LibraryCatalog catalog) {
            if (!catalog.isResourceInCatalog(resource.getId())) {
                catalog.internalAddResource(resource); 
                this.actionsLog.add("Додано ресурс ID: " + resource.getId());
                return true;
            }
            return false;
        }

        @Override
        protected void validate() {
            System.out.println("Admin method: validate - Admin credentials confirmed.");
        }
        
        @Override
        public String getType() { return "AdminAccount"; }

        @Override
        public void displayInfo() {
            System.out.println("ADMIN: " + getFullName() + ", Log count: " + actionsLog.size() + ", Type: " + getType());
        }
    }

    static abstract class LibraryResource extends BaseEntity { // АБСТРАКТНИЙ
        protected String title;
        protected String author;

        public LibraryResource(int id, String title, String author) {
            super(id);
            this.title = title;
            this.author = author;
            validate();
        }

        public abstract boolean isAvailable(); // АБСТРАКТНИЙ МЕТОД
        public abstract void viewContent(); // АБСТРАКТНИЙ МЕТОД

        @Override
        protected void validate() {
            System.out.println("LibraryResource method: validate - Basic metadata confirmed.");
        }

        public String getTitle() {return title;}
        public String getAuthor() {return author;}
    }
    
    static class Book extends LibraryResource {
        private int year;
        private String fileLink;
        private boolean available;

        public Book(int id, String title, String author, int year, String fileLink) {
            super(id, title, author);
            this.year = year;
            this.fileLink = fileLink;
            this.available = true;
        }

        @Override
        public boolean isAvailable() {return available;}
        public void setFileLink(String fileLink) {this.fileLink = fileLink;}

        void setAvailability(boolean status) {
            this.available = status;
        }
        
        @Override
        public void viewContent() {
            System.out.println("Book method: viewContent - Displaying text content.");
        }

        @Override
        public String getType() { return "ElectronicBook"; }

        @Override
        public void displayInfo() {
            System.out.println("Book: Title: " + title + ", Author: " + author + ", Available: " + available + ", Type: " + getType());
        }
    }
    
    static class AudioBook extends LibraryResource {
        private int durationSeconds;
        private boolean available;
        
        public AudioBook(int id, String title, String author, int durationSeconds) {
            super(id, title, author);
            this.durationSeconds = durationSeconds;
            this.available = true;
        }

        @Override
        public boolean isAvailable() {return available;}
        
        @Override
        public void viewContent() {
            System.out.println("AudioBook method: viewContent - Playing audio file.");
        }

        @Override
        public String getType() { return "AudioResource"; }

        @Override
        public void displayInfo() {
            System.out.println("AudioBook: Title: " + title + ", Duration: " + durationSeconds / 60 + " min., Type: " + getType());
        }
    }

    static class LibraryCatalog {
        private List<LibraryResource> resources;
        private String catalogName;

        public LibraryCatalog(String catalogName) {
            this.catalogName = catalogName;
            this.resources = new ArrayList<>();
        }

        public int getTotalResourceCount() {return resources.size();}
        public boolean isResourceInCatalog(int resourceId) {return resources.stream().anyMatch(r -> r.getId() == resourceId);}

        void internalAddResource(LibraryResource resource) {
            this.resources.add(resource);
        }
        
        // Поліморфний метод: працює з абстрактним типом LibraryResource
        public void listResources(String resourceType) {
            System.out.println("Catalog method: listResources - Listing " + resourceType + "s:");
            for (LibraryResource resource : resources) { // Звернення через абстрактний клас
                if (resource.getType().equals(resourceType)) {
                    resource.displayInfo(); // Поліморфний виклик
                }
            }
        }
        
        @Override
        public String toString() {
            return "LibraryCatalog [Name=" + catalogName + ", Total Resources=" + resources.size() + "]";
        }
    }

    static class DownloadOrder extends BaseEntity {
        private int userId;
        private int resourceId;
        private LocalDateTime downloadDateTime;

        public DownloadOrder(int downloadId, int userId, int resourceId) {
            super(downloadId);
            this.userId = userId;
            this.resourceId = resourceId;
        }
        
        // Поліморфний метод: приймає абстрактний тип
        public boolean processDownload(SystemUser user, LibraryResource resource) {
            if (!resource.isAvailable()) { // Поліморфний виклик абстрактного методу
                System.out.println(" Помилка: Ресурс недоступний для завантаження.");
                return false;
            }
            
            this.userId = user.getId();
            this.resourceId = resource.getId();
            this.downloadDateTime = LocalDateTime.now();
            
            // Якщо ресурс є Book, викликаємо спеціалізований метод (для демонстрації)
            if (resource instanceof Book) {
                ((Book) resource).setAvailability(false); 
            }
            
            System.out.println(" Завантаження ресурсу ID " + resource.getId() + " успішне!");
            resource.viewContent(); // Поліморфний виклик
            return true;
        }

        @Override
        protected void validate() {} 

        @Override
        public String getType() { return "DownloadTransaction"; }
        
        @Override
        public void displayInfo() {
            System.out.println("DownloadOrder [ID=" + id + ", User ID=" + userId + ", Resource ID=" + resourceId + "]");
        }
    }
    
    static class Category {
        private int categoryId;
        private String name;
        private List<Integer> resourceIds;

        public Category(int categoryId, String name) {
            this.categoryId = categoryId;
            this.name = name;
            this.resourceIds = new ArrayList<>();
        }

        public void assignResource(int resourceId) {
            if (!resourceIds.contains(resourceId)) {
                resourceIds.add(resourceId);
            }
        }
        
        @Override
        public String toString() {
            return "Category [ID=" + categoryId + ", Name='" + name + "', Resources=" + resourceIds.size() + "]";
        }
    }

    public static void main(String[] args) {
        System.out.println("--- ПР 3, 4, 5 & 6: Абстракція та Поліморфізм ---");

        System.out.println("\n>>> 1. Створення об'єктів через Фабрику (класи Book та AudioBook):\n");
        
        User standardUser = EntityFactory.createUser("Олена", "Іваненко", "olena_i", "pass123");
        Admin libraryAdmin = EntityFactory.createAdmin("Петро", "Сидоренко", "admin_p", "root");
        
        Book book1 = EntityFactory.createBook("Java. Ефективне програмування", "Джошуа Блох", 2019, "/files/java.pdf");
        AudioBook audio1 = EntityFactory.createAudioBook("Міфи Стародавньої Греції", "Стівен Фрай", 3600);
        
        LibraryCatalog mainCatalog = new LibraryCatalog("Центральний Каталог");
        mainCatalog.internalAddResource(book1);
        mainCatalog.internalAddResource(audio1);
        
        DownloadOrder order1 = EntityFactory.createDownloadOrder(standardUser, book1);

        System.out.println("\n>>> 2. Демонстрація поліморфізму (Звернення через абстрактний клас BaseEntity):\n");
        
        System.out.println("Поліморфний список користувачів:");
        for (SystemUser user : Storage.USERS) { // Звернення через SystemUser
            user.displayInfo(); // Поліморфний виклик
        }

        System.out.println("\nПоліморфний виклик методу viewContent (LibraryResource):");
        book1.viewContent();  // Пряме посилання Book
        audio1.viewContent(); // Пряме посилання AudioBook
        
        System.out.println("\n----------------------------------------");
        
        System.out.println(">>> 3. Демонстрація поліморфних сервісних функцій (Catalog та DownloadOrder):");
        
        // 3.1. Поліморфізм у LibraryCatalog
        mainCatalog.listResources("ElectronicBook");
        mainCatalog.listResources("AudioResource");
        
        // 3.2. Поліморфізм у DownloadOrder (одна функція для різних ресурсів)
        System.out.println("\nСтатус книги (Book1) ДО завантаження: " + book1.isAvailable());
        order1.processDownload(standardUser, book1); // Працює з Book
        System.out.println("Статус книги (Book1) ПІСЛЯ завантаження: " + book1.isAvailable());
        
        System.out.println("\nСпроба завантажити AudioBook:");
        DownloadOrder order2 = EntityFactory.createDownloadOrder(standardUser, audio1);
        order2.processDownload(libraryAdmin, audio1); // Працює з AudioBook
        
        System.out.println("\n--- Завершення роботи ---");
    }
}
